# Kokoro-82M 디스코드 TTS 봇 개발 계획

## 1. 목표 및 범위
- Kokoro-82M 음성 합성 모델을 활용해 디스코드 음성 채널에서 실시간 TTS 제공
- 텍스트 명령어 및 슬래시 커맨드 기반 상호작용 지원
- 최소한의 지연으로 안정적인 음성 스트리밍 구현

## 2. 선행 조건
- Python 3.10 이상, `discord.py 2.x`
- Kokoro-82M 모델 가중치(ONNX 또는 PyTorch)와 추론 스크립트 확보
- FFmpeg 설치(로컬 PCM/WAV → Opus 변환 용도)
- GPU 사용 시 CUDA 환경, CPU 백업 경로 마련
- 디스코드 봇 토큰 및 음성 권한 관리

## 3. 아키텍처 개요
- `Bot Core`: `discord.ext.commands.Bot` 기반 이벤트 루프 및 슬래시 커맨드 등록
- `TTS Pipeline`: 텍스트 정규화 → Kokoro 추론 → PCM/WAV 생성 → Opus 변환
- `Session Manager`: 음성 채널 연결 상태, 재생 큐, 동시 요청 제한 제어
- `Config & Secrets`: `.env` 로 민감 정보 관리, 설정 객체 주입
- `Logging & Metrics`: 구조화 로그 + 기본 모니터링(재생 시간, 큐 길이)

## 4. 구현 단계
1. **환경 구축**: 가상 환경, 의존성 명세(`pyproject.toml`), 예시 `.env` 작성
2. **설정 모듈**: 환경변수 로딩, 경로/리소스 검증 유틸
3. **Kokoro 래퍼**: 모델 로드, 음성 샘플 생성 함수, 캐시/온디맨드 로드 전략
4. **오디오 변환기**: PCM → Opus 파이프 구성(FFmpeg 서브프로세스 or `discord.FFmpegPCMAudio`)
5. **봇 골격**: 연결 이벤트, 기본 명령(`join`, `leave`, `ping`) 구현
6. **TTS 명령어**: 텍스트 입력 검증, 언어/화자 선택 옵션, 큐 enqueue → 재생 루프
7. **동시성 제어**: asyncio 큐, 작업 취소, 타임아웃, 에러 핸들링
8. **로깅/에러 처리**: 구조화 로그 출력, 예외 핸들러
9. **테스트/검증**: 단위 테스트(모델 래퍼 더블), 통합 테스트(모의 디스코드), 로컬 음성 채널 검증

## 5. 테스트 전략
- 모델 래퍼: 입력 길이/언어별 출력 검사, 캐시 적중률 확인
- 오디오 파이프라인: 생성 파일 포맷/샘플레이트 비교, FFmpeg 실패 시 폴백
- 봇 명령: `pytest` + `discord.py` 테스트 더블, 슬래시 커맨드 시나리오
- 부하 테스트: 긴 문장, 여러 사용자 큐 적재 후 지연/메모리 측정

## 6. 배포 및 운영
- Docker 컨테이너화(모델 가중치 마운트, FFmpeg 포함)
- 프로세스 관리자(systemd 또는 supervisord)로 봇 재시작 보장
- 로그 집계 및 알림(Webhook) 구성, 봇 토큰 교체 절차 문서화
- 모델/의존성 업데이트 시 회귀 테스트 체크리스트 유지

## 7. 리스크 및 대응
- **모델 로드 지연**: 시작 시 프리로드 + 온디맨드 캐시
- **메모리 사용량**: 스트리밍 후 버퍼 해제, 캐시 크기 제한
- **디스코드 레이턴시**: 텍스트 길이 제한, 큐 처리 상태 알림
- **FFmpeg 실패**: 서브프로세스 모니터링, 재시도 및 대체 경로(PCM 직재생)

## 8. 후속 작업
- 멀티 언어/화자 프로필 확장
- 웹 대시보드로 큐 상태/로그 모니터링
- 사용자별 TTS 프리셋 저장 및 관리 UI 설계
